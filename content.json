{"meta":{"title":"Shih's blog","subtitle":"","description":"","author":"shih","url":"https://hangyyds.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-02-14T12:25:34.646Z","updated":"2022-02-14T12:25:34.646Z","comments":false,"path":"/404.html","permalink":"https://hangyyds.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-02-14T12:25:34.647Z","updated":"2022-02-14T12:25:34.647Z","comments":false,"path":"about/index.html","permalink":"https://hangyyds.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-02-14T12:25:34.647Z","updated":"2022-02-14T12:25:34.647Z","comments":false,"path":"books/index.html","permalink":"https://hangyyds.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-02-14T12:25:34.647Z","updated":"2022-02-14T12:25:34.647Z","comments":false,"path":"categories/index.html","permalink":"https://hangyyds.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-02-14T12:25:34.647Z","updated":"2022-02-14T12:25:34.647Z","comments":true,"path":"links/index.html","permalink":"https://hangyyds.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-14T12:25:34.648Z","updated":"2022-02-14T12:25:34.648Z","comments":false,"path":"tags/index.html","permalink":"https://hangyyds.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-02-14T12:25:34.648Z","updated":"2022-02-14T12:25:34.648Z","comments":false,"path":"repository/index.html","permalink":"https://hangyyds.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"02-WebWork的学习","slug":"02-WebWork的学习","date":"2022-03-04T06:30:34.000Z","updated":"2022-03-04T08:21:14.256Z","comments":true,"path":"2022/03/04/02-WebWork的学习/","link":"","permalink":"https://hangyyds.github.io/2022/03/04/02-WebWork%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"WebWork的学习常用的HTML标签 参考手册：https://www.w3school.com.cn/tags/index.asp WebWork标签库通用标签 &lt;ww:property /&gt; 获取结果的属性值. 如果值未指定, 将返回栈顶值. &lt;ww:push /&gt; 将一个值压入值栈. &lt;ww:param /&gt; 设置父标签的参数. 仅用于其他标签内部, 用于设置父标签某些属性的值. &lt;ww:set /&gt; 将值栈中的某个对象的值设置到一个scope(page, stack, application, session)中. 如果值未给定, 将使用栈顶值. 如果scope未给定, 使用”webwork”的缺省scope. &lt;ww:url /&gt; 构建一个编码的URL. 组件化标签 &lt;ww:action /&gt; 在标签库的上下文环境中执行一个活动. 标签的主体用来显示活动执行的结果. &lt;ww:bean /&gt; 创建一个JavaBean, 初始化它的属性并放入ActionContext以便后续使用. &lt;ww:include /&gt; 包含另一个页面或活动. 流程控制标签 &lt;ww:if /&gt; 有条件执行路径. 换言之, 如果布尔条件是true的话, 就运算标签主体内容. &lt;ww:else /&gt; if标签的反向执行路径. 换言之, 如果前一个if标签的布尔条件是false的话, 就运算标签主体内容. &lt;ww:elseif /&gt; if标签的反向执行路径. 换言之, 如果前一个if标签的布尔条件是false且本标签的布尔条件是true的话, 就运算标签主体内容. 迭代标签 &lt;ww:iterator /&gt; 在一个集合(collection)上迭代. &lt;ww:generator /&gt; 生成迭代器(Iterator). &lt;ww:append /&gt; 添加几个迭代器. &lt;ww:subset /&gt; 获取一个迭代器的子集. &lt;ww:merge /&gt; 合并几个迭代器. &lt;ww:sort /&gt; 对迭代器进行排序. UI标签 &lt;ww:form /&gt; 所有其他UI标签的容器 &lt;ww:textfield /&gt; 创建一个文本框 &lt;ww:password /&gt; 创建一个密码输入框 &lt;ww:textarea /&gt; 创建一个文本输入域 &lt;ww:checkbox /&gt; 创建一个复选框 &lt;ww:select /&gt; 创建一个下拉框 &lt;ww:radio /&gt; 创建一组单选按钮 &lt;ww:checkboxlist /&gt; 创建一组复选框 &lt;ww:label /&gt; 创建一个标签 &lt;ww:hidden /&gt; 创建一个隐藏域 &lt;ww:doubleselect /&gt; 创建一组相关联的下拉框 &lt;ww:combobox /&gt; 创建一个下拉输入框（既可以选择下拉框中的选项，也可以自己输入内容） &lt;ww:component /&gt; 创建一个自定义的控件（通过Velocity模版的信息） 国际化标签 &lt;ww:text /&gt; 输出一个经过国际化处理的字符串. &lt;ww:i18n /&gt; 将国际化资源包(resource bundle)放入值栈中, 为text标签使用. 参考：https://blog.csdn.net/sun305355024sun/article/details/5392958","categories":[{"name":"java","slug":"java","permalink":"https://hangyyds.github.io/categories/java/"}],"tags":[{"name":"webWork","slug":"webWork","permalink":"https://hangyyds.github.io/tags/webWork/"}]},{"title":"01-Markdown手册","slug":"01-Markdown手册","date":"2022-02-25T03:12:52.000Z","updated":"2022-03-04T07:23:47.313Z","comments":true,"path":"2022/02/25/01-Markdown手册/","link":"","permalink":"https://hangyyds.github.io/2022/02/25/01-Markdown%E6%89%8B%E5%86%8C/","excerpt":"","text":"『Cmd 技术渲染的沙箱页面，点击此处编写自己的文档』 Cmd Markdown 简明语法手册标签： Cmd-Markdown 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： 10.颜色字体使用&lt;font color=red&gt;红色字体&lt;/font&gt;来上色。 1234567891011&lt;font face=&quot;黑体&quot;&gt;实现字体为黑体&lt;/font&gt;&lt;small&gt;比默认字体小一号&lt;/small&gt;这里显示的是浏览器默认字体大小&lt;font size=4&gt;实现字体大小改变&lt;/font&gt;&lt;big&gt;比默认字体大一号&lt;/big&gt;&lt;font color=red&gt;实现字体颜色为红色&lt;/font&gt;&lt;span style=&quot;background-color: orange&quot;&gt;实现背景填充为橙色&lt;/span&gt;&lt;font color=#FF69B4&gt;字体颜色值也可以用十六进制表示&lt;/font&gt;&lt;span style=&quot;background-color: #D3D3D3&quot;&gt;背景颜色值也可以用十六进制表示&lt;/span&gt;&lt;font face=&quot;黑体&quot; size=4 color=red&gt;实现字体效果：黑体、4号、红色&lt;/font&gt;&lt;span style=&quot;background-color: #D3D3D3&quot;&gt;&lt;font size=4 color=#DC143C&gt;默认字体，4号，使用十六进制表示颜色值&lt;/font&gt;&lt;/span&gt; 实现字体为黑体比默认字体小一号这里显示的是浏览器默认字体大小实现字体大小改变比默认字体大一号实现字体颜色为红色实现背景填充为橙色字体颜色值也可以用十六进制表示背景颜色值也可以用十六进制表示实现字体效果：黑体、4号、红色默认字体，4号，使用十六进制表示颜色值 11.内嵌页面 Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): &#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Greater&#x27; return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 1234567891011121314gantttitle 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图12345graph LRA[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图 Alice-&gt;John: Hello John, how are you? loop every minute John--&gt;Alice: Great! end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 13. 定义型列表名词 1定义 1（左侧有一个可见的冒号和四个不可见的空格）代码块 2这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： Cmd Markdown 开发 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 语法参考 改进 LaTex 功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 语法参考 七月旅行准备 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。 转载于：https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#","categories":[{"name":"Tools","slug":"Tools","permalink":"https://hangyyds.github.io/categories/Tools/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://hangyyds.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"01-Spring的学习","slug":"01-Spring的学习","date":"2022-02-21T08:25:57.000Z","updated":"2022-02-25T03:16:43.320Z","comments":true,"path":"2022/02/21/01-Spring的学习/","link":"","permalink":"https://hangyyds.github.io/2022/02/21/01-Spring%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Spring的学习​ Spring 的核心是一个 容器，通常称为 Spring 应用程序上下文，用于创建和管理应用程序组件。这些组件（或 bean）在 Spring 应用程序上下文中连接在一起以构成一个完整的应用程序，就像将砖、灰浆、木材、钉子、管道和电线绑在一起以组成房屋。 ​ 将 bean 连接在一起的行为是基于一种称为 依赖注入（DI）的模式。依赖项注入的应用程序不是由组件自身创建和维护它们依赖的其他 bean 的生命周期，而是依赖于单独的实体（容器）来创建和维护所有组件，并将这些组件注入需要它们的 bean。通常通过构造函数参数或属性访问器方法完成此操作。 ​ 从历史上看，引导 Spring 应用程序上下文将 bean 连接在一起的方式是使用一个或多个 XML 文件，这些文件描述了组件及其与其他组件的关系。 Spring风景线Spring核心框架 提供了核心容器和依赖注入框架，也提供了一些其他的基本特性：包括 Spring MVC 和 Spring web 框架，还提供了一些基本数据持久性支持，特别是基于模板的 JDBC 支持。 Spring Boot 启动依赖项和自动配置、运行时监控。 Spring Data 将应用程序的数据存储库抽象为简单的 Java 接口，同时当定义方法用于如何驱动数据进行存储和检索的问题时，对方法使用了命名约定。Spring Data 能够处理几种不同类型的数据库，包括关系型（JPA）、文档型（Mongo）、图型（Neo4j）等 Spring Security Spring Security 解决了广泛的应用程序安全性需求，包括身份验证、授权和 API 安全性。 Spring Integration 和 Spring Batch 在某种程度上，大多数应用程序将需要与其他应用程序集成，甚至需要与同一应用程序的其他组件集成。为了满足这些需求，出现了几种应用程序集成模式。Spring Integration 和 Spring Batch 为基于 Spring 的应用程序提供了这些模式的实现。 Spring Integration 解决了实时集成，即数据在可用时进行处理。相反，Spring Batch 解决了批量集成的问题，允许在一段时间内收集数据，直到某个触发器（可能是一个时间触发器）发出信号，表示该处理一批数据了。 Spring Cloud 微服务 Spring项目结构解析 mvnw 和 mvnw.cmd —— 这些是 Maven 包装器脚本。即使你的计算机上没有安装 Maven，也可以使用这些脚本构建项目。 pom.xml —— 这是 Maven 构建规范。 &lt;packaging&gt; 元素——选择将应用程序构建为可执行的 JAR 文件，而不是 WAR 文件。 &lt;parent&gt; 元素——指定您的项目将 spring-boot-starter-parent 作为它的父 POM。除此之外，这个父 POM 还为 Spring 项目中常用的几个库提供依赖项管理。对于父 POM 覆盖的那些库，不必指定版本，因为它是从父 POM 继承的。2.0.4.RELEASE 版本，表示你正在使用 Spring Boot 2.0.4，这样项目将使用继承自 Spring Boot 版本中定义的依赖项管理。 Spring注解@Configuration @Configuration注释向 Spring 表明这是一个配置类，它将为 Spring 应用程序上下文提供 beans。 配置的类方法带有 @Bean 注释，指示它们返回的对象应作为 beans 添加到应用程序上下文中（默认情况下，它们各自的 bean IDs 将与定义它们的方法的名称相同）。 123456789101112@Configurationpublic class ServiceConfiguration &#123; @Bean public InventoryService inventoryService() &#123; return new InventoryService(); &#125; @Bean public ProductService productService() &#123; return new ProductService(inventoryService()); &#125;&#125; @SpringBootApplication @SpringBootApplication 注释清楚地表明这是一个 Spring 引导应用程序。但是 @SpringBootApplication 中有更多的东西。@SpringBootApplication 是一个组合了其他三个注释的复合应用程序： @SpringBootConfiguration —— 指定这个类为配置类。尽管这个类中还没有太多配置，但是如果需要，可以将 Javabased Spring Framework 配置添加到这个类中。实际上，这个注释是@Configuration 注释的一种特殊形式。 @EnableAutoConfiguration —— 启用 Spring 自动配置，告诉 Spring Boot 自动配置它认为需要的任何组件。例如，添加了 spring-boot-starter-web 依赖，会自动添加 Tomcat 和 Spring MVC 的依赖，那么 Spring Boot 会对 Tomcat 和 Spring MVC 进行自动配置。 @ComponentScan —— 启用组件扫描。这允许你声明其他带有 @Component、@Controller、@Service 等注释的类，以便让 Spring 自动发现它们并将它们注册为 Spring 应用程序上下文中的组件。 @RunWith(SpringRunner.class) @RunWith 是一个 JUnit 注释，提供了一个测试运行器来引导 JUnit 运行测试用例。JUnit 被赋予了 SpringRunner，这是一个由 Spring 提供的测试运行程序，它提供了创建一个 Spring 应用程序上下文的功能，以供测试运行。 @SpringBootTest 告诉 JUnit 使用 Spring 引导功能引导测试。 @Controller 将该类识别为组件扫描的组件，以便 Spring 将发现该类并在 Spring 应用程序上下文中自动创建实例作为 bean。实际上，其他一些注释（包括 @Component、@Service 和 @Repository）的用途与 @Controller 类似。 @GetMapping(“/“) 以指示如果接收到根路径 / 的 HTTP GET 请求，则此方法应该处理该请求。 @RequestMapping(“/“) @RequestMapping ——通用请求处理，注释在类级应用时，指定该控制器处理的请求的类型。 @GetMapping——处理 HTTP GET 请求 @PostMapping——处理 HTTP POST 请求 @PutMapping——处理 HTTP PUT 请求 @DeleteMapping——处理 HTTP DELETE 请求 @PatchMapping——处理 HTTP PATCH 请求 Spring Web开发​ 在 Spring web 应用程序中，获取和处理数据是控制器的工作。视图的工作是将数据渲染成 HTML 并显示在浏览器中。 控制器类controller​ 控制器是 Spring MVC 框架的主要参与者。它们的主要工作是处理 HTTP 请求，或者将请求传递给视图以呈现 HTML（浏览器显示），或者直接将数据写入响应体（RESTful）。 验证表单输入​ 执行表单验证的一种方法是在方法中加入一堆 if/then 块，检查每个字段以确保它满足适当的验证规则。但是这样做会很麻烦，并且难于阅读和调试。幸运的是，Spring 支持 Java’s Bean Validation API（也称为 JSR-303；https://jcp.org/en/jsr/detail?id=303）。这使得声明验证规则比在应用程序代码中显式地编写声明逻辑更容易。 1234567891011121314151617package tacos;​import java.util.List;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;import lombok.Data;​@Datapublic class Taco &#123; @NotNull @Size(min=5, message=&quot;Name must be at least 5 characters long&quot;) private String name; @Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;) private List&lt;String&gt; ingredients;&#125; ​ 需要将 Java Bean Validation API 的 @Valid 注释添加到参数中，来验证提交的对象。@Valid 注释告诉 Spring MVC 在提交的 Taco 对象绑定到提交的表单数据之后，以及调用 processDesign() 方法之前，对提交的 Taco 对象执行验证。如果存在任何验证错误，这些错误的详细信息将在传递到 processDesign() 的错误对象中捕获。 1234567891011@PostMappingpublic String processDesign(@Valid Taco design, Errors errors) &#123; if (errors.hasErrors()) &#123; return &quot;design&quot;; &#125; // Save the taco design... // We&#x27;ll do this in chapter 3 log.info(&quot;Processing design: &quot; + design); return &quot;redirect:/orders/current&quot;;&#125; 视图模板库","categories":[{"name":"Java","slug":"Java","permalink":"https://hangyyds.github.io/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://hangyyds.github.io/categories/Java/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://hangyyds.github.io/tags/Spring/"}]},{"title":"01-对java爬虫的笔记记录","slug":"01-note_Spider","date":"2022-02-16T10:44:48.000Z","updated":"2022-02-18T01:45:39.464Z","comments":true,"path":"2022/02/16/01-note_Spider/","link":"","permalink":"https://hangyyds.github.io/2022/02/16/01-note_Spider/","excerpt":"","text":"对java爬虫的笔记记录前言​ 最近无聊开始瞎折腾爬虫相关的功能，目前只接触到非常浅显的知识，做做笔记吧，不然总觉得一天又白折腾，啥也没收获到。通过在github上的搜索，找到了一个Java开发的爬虫框架–AiPa,一款小巧、灵活的Java多线程爬虫框架，依赖当下最简单的HTML解析器Jsoup，只需要使用者提供网址集合，即可在多线程下自动爬取，并对一些异常进行处理。 AiPa仓库链接：https://github.com/onblog/AiPa AiPa初了解​ 通过实现AiPaWorker接口，来处理html元素，获取你想要的内容。这种方式需要jsoup解析html元素，所以对jsoup工具也要有所了解。还一种方式是直接通过url获取所请求网站的接口，对返回的json数据进行加工处理，来获取你想要的内容。 12345678910111213141516public interface AiPaWorker&lt;T,S&gt; &#123; /** * 如何解析爬下来的HTML文档？ * @param doc JSOUP提供的文档 * @param util 爬虫工具类 * @return */ T run(Document doc, AiPaUtil util); /** * run方法异常则执行fail方法 * @param link 网址 * @return */ S fail(String link);&#125; ​ run()方法是用户自定义处理爬取的HTML内容，一般是利用Jsoup的Document类进行解析，获取节点或属性等，然后保存到数据库或本地文件中。如果在业务方法需要再次请求URL，可以使用工具类Util。 使用HttpURLConnection与所请求服务器连接​ 除了抓取html元素，直接通过服务器接口返回json数据岂不是更香。这两天倒腾了一下，也走了不少弯路，勉强调通了一个接口，抓取微博的热搜榜相关信息。 首先通过chrome浏览器调试获取对应url 基本的步骤如下： 123456789101112131415public void testWeiBoCall()&#123; //1.设置url String path = &quot;https://weibo.com/ajax/statuses/hot_band&quot;; //2.输出路径 String outputPath = &quot;D:\\\\Work\\\\Java\\\\Study\\\\learnByIdea\\\\MySpider\\\\weibo-spider\\\\out\\\\output.txt&quot;; //3.模拟验证登录时，可以配置data，功能暂未实现。 String data = &quot;&quot;; //调接口 String jsonData = MyAiPaUtil.interfaceUtil(path, data); //解析获取的json数据 JsonUtil.parseWeiBoJsonData(jsonData,outputPath);&#125; 使用httpURLConnection建立连接并获取输入流。 12345678910111213141516171819202122232425262728293031323334353637383940414243public static String interfaceUtil(String path, String data)&#123; InputStream input = null; BufferedReader br = null; StringBuffer outStr = new StringBuffer(); try&#123; URL url = new URL(path); //打开和url之间的连接 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); //设置通用的请求属性 connection.setRequestMethod(&quot;GET&quot;); connection.setRequestProperty(&quot;Accept&quot;, &quot;application/json&quot;); connection.setRequestProperty(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36&quot;); //获取字节输入流 input = connection.getInputStream(); br = new BufferedReader(new InputStreamReader(input,&quot;UTF-8&quot;)); String str = &quot;&quot;; while ((str = br.readLine()) != null) &#123; outStr.append(str); &#125; connection.disconnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //关闭流最严谨的写法 if (input != null) &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (br != null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return outStr.toString();&#125; 针对返回的json数据，分析其字段，根据自己想要的数据来定义对应的dto（javabean的编码我就不写啦！）。 使用谷歌的gson工具来解析json数据。 123456789101112131415161718192021222324252627282930313233343536public static void parseWeiBoJsonData(String jsonData, String outputPath) &#123; Gson gson = new Gson(); HotBandDto hotBandDto = gson.fromJson(jsonData, HotBandDto.class); writeToFile(outputPath, hotBandDto);&#125;public static void writeToFile(String outputPath, HotBandDto hotBandDto) &#123; File file = new File(outputPath); WBData data = hotBandDto.getData(); List&lt;BandList&gt; band_list = data.getBand_list(); BandList bandList = new BandList(); try (FileWriter fw = new FileWriter(file); PrintWriter pw = new PrintWriter(fw);) &#123; for (int i = 0; i &lt; band_list.size(); i++) &#123; bandList = band_list.get(i); if (bandList.getCategory() == null) &#123; continue; &#125; pw.println(bandList.getCategory()); pw.flush(); pw.println(i + 1 + &quot;.&quot; + bandList.getWord()); pw.flush(); if (bandList.getMblog().getPage_info() == null) &#123; pw.println(bandList.getMblog().getText()); pw.flush(); &#125; else &#123; pw.println(bandList.getMblog().getPage_info().getContent2()); pw.flush(); &#125; pw.println(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 最后通过printwriter写到文本中。","categories":[{"name":"Java之瞎折腾系列","slug":"Java之瞎折腾系列","permalink":"https://hangyyds.github.io/categories/Java%E4%B9%8B%E7%9E%8E%E6%8A%98%E8%85%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://hangyyds.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Java随手笔记","slug":"Java随手笔记","date":"2022-02-16T00:52:20.000Z","updated":"2022-03-04T01:02:12.625Z","comments":true,"path":"2022/02/16/Java随手笔记/","link":"","permalink":"https://hangyyds.github.io/2022/02/16/Java%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"SpringBootSpringBoot 框架中的 DAO 层、Entity 层、Service 层、Controller 层 一般的项目模块中都有 DAO、Entity、Service、Controller 层。 Entity 层：实体层 数据库在项目中的类 Entity 层是实体层，也就是所谓的 model，也称为 pojo 层，是数据库在项目中的类，该文件包含实体类的属性和对应属性的 set、get 方法； DAO 层： 持久层 主要与数据库进行交互 DAO 层=mapper 层，现在用 Mybatis 逆向工程生成的 mapper 层，其实就是 dao 层。DAO 层会调用 entity 层，DAO 中会定义实际使用到的方法，比如增删改查。DAO 层的数据源和数据库连接的参数都是在配置文件中进行配置的，配置文件一般在同层的 XML 文件夹中。数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作。 Service 层：业务层 控制业务 Service 层主要负责业务模块的逻辑应用设计。先设计放接口的类，再创建实现的类，然后在配置文件中进行配置其实现的关联。service 层调用 dao 层接口，接收 dao 层返回的数据，完成项目的基本功能设计。 封装 Service 层的业务逻辑有利于业务逻辑的独立性和重复利用性。 Controller 层：控制层 控制业务逻辑 Controller 层负责具体的业务模块流程的控制，controller 层负责前后端交互，接受前端请求，调用 service 层，接收 service 层返回的数据，最后返回具体的页面和数据到客户端。Controller 层像是一个服务员，他把客人（前端）点的菜（数据、请求的类型等）进行汇总什么口味、咸淡、量的多少，交给厨师长（Service 层），厨师长则告诉沾板厨师（Dao 1）、汤料房（Dao 2）、配菜厨师（Dao 3）等（统称 Dao 层）我需要什么样的半成品，副厨们（Dao 层）就负责完成厨师长（Service）交代的任务。 在具体的项目中，其流程为： 1Controller--&gt;service接口--&gt;serviceImpl--&gt;dao接口--&gt;daoImpl--&gt;mapper--&gt;db PO,BO,VO 和 POJO 的区别 PO：persistent object 持久对象 有时也被称为 Data 对象，对应数据库中的 entity，可以简单认为一个 PO 对应数据库中的一条记录。 POJO ：plain ordinary java object 无规则简单 java 对象 一个中间对象，可以转化为 PO、DTO、VO。 BO：business object 业务对象 业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个 PO，工作经历对应一个 PO，社会关系对应一个 PO。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO。 这样处理业务逻辑时，我们就可以针对 BO 去处理。 封装业务逻辑为一个对象（可以包括多个 PO，通常需要将 BO 转化成 PO，才能进行数据的持久化，反之，从 DB 中得到的 PO，需要转化成 BO 才能在业务层使用）。 关于 BO 主要有三种概念 1 、只包含业务对象的属性； 2 、只包含业务方法； 3 、两者都包含。 VO：value object 值对象 / view object 表现层对象 对应页面显示（web 页面/swt、swing 界面）的数据对象。 DTO（TO）：Data Transfer Object 数据传输对象 用在需要跨进程或远程传输时，它不应该包含业务逻辑。 比如一张表有 100 个字段，那么对应的 PO 就有 100 个属性（大多数情况下，DTO 内的数据来自多个表）。但 view 层只需显示 10 个字段，没有必要把整个 PO 对象传递到 client，这时我们就可以用只有这 10 个属性的 DTO 来传输数据到 client，这样也不会暴露 server 端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为 VO。 DAO：data access object 数据访问对象 主要用来封装对 DB 的访问（CRUD 操作）。 参考：https://blog.csdn.net/u011870547/article/details/81077153 计算机基础理解字符与字节的含义 参考：https://zhuanlan.zhihu.com/p/110890622 字符 字符指类字形单位或符号，包括字母、数字、运算符号、标点符号和其他符号，以及一些功能性符号。 ​ 为了方便理解，你可以将字符简单地理解为你可以用输入法单独打出的任何单个的内容。对于中文和英文而言，以下内容分别都是1个字符： （1）1个中文字，例如“是” （2）1个英文字母，例如“T” （3）1个中文标点符号，例如“。” （4）1个英文标点符号，例如“.” 字节 字节（Byte）是计算机信息技术用于计量存储容量的一种计量单位。 ​ 如果你只是在纸上写字，那么就用不到字节，但是如果你要把字存入电脑，就需要占用一定的磁盘空间。我们知道，电脑只能用高电位、低电位的形式存储数据，抽象出来，那就是电脑存数据最终只能用二进制的形式，也就是用0和1表示，无论任何数据，最终存储的时候都是一段包含多个0和1的串，例如“00110101”，这里的每一个0或1被称为1位。“位”就是最小的存储单位，然后我们把8位称为1个字节，也就是1个字节等于8位。这个概念类似于“1公里=1000米”，本质上是一回事，只是使用不同级别的单位而已。由于二进制实在太长，不方便展示，所以一般将1个字节（8位）的二进制转换成十六进制进行展示，例如将11010011转换成十六进制就是D3，这就是一个字节。 搞懂MySQL的数据类型中长度的含义 参考：https://zhuanlan.zhihu.com/p/111028232 字符串类型​ 常用的字符串类型的数据类型有 CHAR 和 VARCHAR 两种，两者后面都需要跟上一个数字表示长度，例如： 1234//CHAR(n) 和 VARCHAR(n) 两者中的 n 含义均为该字段最大可容纳的字符数。//CHAR(n) 和 VARCHAR(n) 字段值的占用空间不是固定的，而是由实际存入的内容决定的CHAR(10) VARCHAR(10) ​ 对于 CHAR(4) 表示固定容纳4个字符，当少于4个字符时，会使用空格填充空缺的部分，使其达到4个字符。如果超过4个字符，会自动截断超出部分。 ​ 区别于 CHAR 类型的补空， VARCHAR 类型对于未达到 n 字符的情况不会补空。 整数类型​ 常用的整数数据类型有 tinyint ，smallint ，mediumint ， int ，bigint 共计5种，在声明列时，后面也可以跟上 n ，例如 int(n) 。实际上这里的 n 非常鸡肋，几乎没有任何使用场景。它的含义是“显示位宽”，这个 n 无论填任何数，不影响存储环节，仅影响在检索时的输出格式，而且在非常严格的情况下才成立。 12345tinyint ：1个字节，smallint ：2个字节，mediumint ：3个字节，int ：4个字节，bigint ：8个字节。 ​ 很多人说经常记不住他们的取值范围，实际上很好算，例如 tinyint 占用1个字节，也就是8位，每1位都包含0和1两种情况，因此共2的8次方为256种情况，如果是无符号（unsigned），取值范围就是0至255。如果是有符号情况，由于第1位要用来表示符号，因此可用7位表示数字，2的7次方为128，再加上符号，取值范围为 -128至127 。其它几种数据类型也可以按照这个方法计算。&gt; ​ 另外再补充一点，当插入的值，超出取值范围的时候，MySQL并不会报错，而是自动变成成在取值范围内最接近该值的边界值。例如字段为 tinyint ，有符号型时取值范围 -128至127 ，当你输入-222时，不会报错，会自动存入最接近-222的-128，当你输入222时，会自动存入127。这一点需要尤其注意，否则很容易造成巨大的bug。 浮点型​ FLOAT 类型固定占用4个字节， DOUBLE 类型固定占用8个字节，逻辑和上述的整型类似。 ​ DECIMAL 类型，它的定义方式是 DECIMAL(M,D) ，其中 M 表示最大位数，D 表示小数点右侧的位数。这里的“位”不是二进制的比特位，而是指十进制的数字的位数。例如我们定义 DECIMAL(5,2) ，则表示最大位数为5位，小数点后2位，因此小数点前还剩下3位，于是取值范围为 -999.99至999.99 。 ​ DECIMAL(M,D) 的存储方式和其他数字类型都完全不同&gt;，它是以字符串形式进行存储的。这可能有点不好理解，以整型 tinyint 为例，它存储的值是直接为十进制到二进制的转换，以无符号型为例，当需要存入的值为100值，将100转化为二进制为1100100 ，使用1个字节即8位记录，实际存入的是 01100100 。但是用 DECIMAL 类型存储时，比如定义 DECIMAL(3,0) ，存入100时，实际存入的是由字符“1”，“0”，“0”拼接而成的字符串“100”的二进制值，存入时占用3个字节，分别是31，30，30（注意这是十六进制）。","categories":[{"name":"Java","slug":"Java","permalink":"https://hangyyds.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hangyyds.github.io/tags/Java/"}]},{"title":"开启博客之旅","slug":"开启博客之旅","date":"2022-02-14T08:09:59.000Z","updated":"2022-02-18T02:25:04.692Z","comments":true,"path":"2022/02/14/开启博客之旅/","link":"","permalink":"https://hangyyds.github.io/2022/02/14/%E5%BC%80%E5%90%AF%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/","excerpt":"","text":"创建的第一篇文章，博客搭建并托管 github 成功。","categories":[{"name":"Test","slug":"Test","permalink":"https://hangyyds.github.io/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://hangyyds.github.io/tags/Test/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-02-14T08:00:51.112Z","updated":"2022-02-16T08:46:56.472Z","comments":true,"path":"2022/02/14/hello-world/","link":"","permalink":"https://hangyyds.github.io/2022/02/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"https://hangyyds.github.io/categories/java/"},{"name":"Tools","slug":"Tools","permalink":"https://hangyyds.github.io/categories/Tools/"},{"name":"Java","slug":"Java","permalink":"https://hangyyds.github.io/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://hangyyds.github.io/categories/Java/Spring/"},{"name":"Java之瞎折腾系列","slug":"Java之瞎折腾系列","permalink":"https://hangyyds.github.io/categories/Java%E4%B9%8B%E7%9E%8E%E6%8A%98%E8%85%BE%E7%B3%BB%E5%88%97/"},{"name":"Test","slug":"Test","permalink":"https://hangyyds.github.io/categories/Test/"}],"tags":[{"name":"webWork","slug":"webWork","permalink":"https://hangyyds.github.io/tags/webWork/"},{"name":"工具","slug":"工具","permalink":"https://hangyyds.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Spring","slug":"Spring","permalink":"https://hangyyds.github.io/tags/Spring/"},{"name":"爬虫","slug":"爬虫","permalink":"https://hangyyds.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Java","slug":"Java","permalink":"https://hangyyds.github.io/tags/Java/"},{"name":"Test","slug":"Test","permalink":"https://hangyyds.github.io/tags/Test/"}]}